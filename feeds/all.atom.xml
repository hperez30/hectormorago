<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Hector' log</title><link href="/hectormorago/" rel="alternate"></link><link href="/hectormorago/feeds/all.atom.xml" rel="self"></link><id>/hectormorago/</id><updated>2020-04-06T20:31:00+02:00</updated><subtitle>A personal blog.</subtitle><entry><title>About Me</title><link href="/hectormorago/about-me.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/about-me.html</id><summary type="html">&lt;p&gt;This section provides a summarize of my research interests.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" type="text/css"&gt;
&lt;script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h2&gt;Research interest&lt;/h2&gt;
&lt;p&gt;My research interests include, but are not limited to Variability Modeling, 
Software Product Lines, Feature Models, software testing, Binary Decision 
Diagrams, and Bibliometric Techniques.&lt;/p&gt;
&lt;h2&gt;Publications&lt;/h2&gt;
&lt;h3&gt;Speeding up Derivative Configuration from Product Platforms&lt;/h3&gt;
&lt;p&gt;Heradio, R.; Fernandez-Amoros, D.; &lt;strong&gt;Perez-Morago, H.&lt;/strong&gt;; Adan, A&lt;/p&gt;
&lt;div&gt;
    &lt;img src="https://www.mdpi.com/img/journals/entropy-logo.png?78b1902e596e9c35" alt="entropy-logo" title="entropy Open Access Journals" style="max-height: 60px; margin: 0 0 0 0;"&gt;
    &lt;div id='journal'&gt;
        &lt;spam class="label label-success"&gt;Journal Paper&lt;/spam&gt;
        Entropy June 2014, Volume 17, Pages 3329-3356
    &lt;/div&gt;
    &lt;div id='impact-factor'&gt;
        &lt;spam class="label label-danger"&gt;Impact factor&lt;/spam&gt;
        &lt;strong id='impact-factor-number-entropy'&gt;&lt;/strong&gt;
        (Journal Citation Reports) | 2nd Quartile
    &lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;Augmenting Measure Sensitivity to Detect Essential, Dispensable and Highly Incompatible Features in Mass Customization&lt;/h3&gt;
&lt;p&gt;Heradio, R.; &lt;strong&gt;Perez-Morago, H.&lt;/strong&gt;; Alferez, M.; Fernandez-Amoros, D.; Alferez G.&lt;/p&gt;
&lt;div&gt;
    &lt;img src="https://ars.els-cdn.com/content/image/X03772217.jpg" alt="ejor-logo" title="European Journal of Operational Research" style="max-height: 80px; margin: 0 0 0 0;"&gt;
    &lt;div id='journal'&gt;
        &lt;spam class="label label-success"&gt;Journal Paper&lt;/spam&gt;
        Journal Paper European Journal of Operational Research, August 2015, 248(3):1066-1077
    &lt;/div&gt;
    &lt;div id='impact-factor'&gt;
        &lt;spam class="label label-danger"&gt;Impact factor&lt;/spam&gt;
        &lt;strong id='impact-factor-number-ejor'&gt;2.679&lt;/strong&gt;
        (Journal Citation Reports) | 1st Quartile
    &lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;A Bibliometric Analysis of 20 Years of Research on Software Product Lines&lt;/h3&gt;
&lt;p&gt;Heradio, R.; &lt;strong&gt;Perez-Morago, H.&lt;/strong&gt;; Fernandez-Amoros, D.; Cabrerizo, 
Francisco Javier; Herrera-Viedma, Enrique&lt;/p&gt;
&lt;div&gt;
    &lt;img src="https://ars.els-cdn.com/content/image/X09505849.jpg" alt="ist-logo" title="Information and Software Technology" style="max-height: 80px; margin: 0 0 0 0;"&gt;
    &lt;div id='journal'&gt;
        &lt;spam class="label label-success"&gt;Journal Paper&lt;/spam&gt;
        Information and Software Technology, 72, April 2016
    &lt;/div&gt;
    &lt;div id='impact-factor'&gt;
        &lt;spam class="label label-danger"&gt;Impact factor&lt;/spam&gt;
        &lt;strong id='impact-factor-number-ejor'&gt;1.569&lt;/strong&gt;
        (Journal Citation Reports) | 2nd Quartile
    &lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;Efficient Identification of Core and Dead Features in Variability Models&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Hector Perez-Morago&lt;/strong&gt;, Ruben Heradio, David Fernandez-Amoros, Roberto Bean and 
Jose Antonio Cerrada Journal Paper IEEE Access. Nov 2015&lt;/p&gt;
&lt;div&gt;
    &lt;img src="https://ieeeaccess.ieee.org/wp-content/uploads/2016/05/IEEE_ACCESS_Logo-noTagline_FullColor_RGB-plus-margin-7800x2000-X-1000.png" alt="ieee_access-logo" title="IEEE Access" style="float: left ;max-height: 60px; margin: 0 0 0 0;"&gt;
    &lt;div id='journal'&gt;
        &lt;spam class="label label-success"&gt;Journal Paper&lt;/spam&gt;
        IEEE Access. Nov 2015
    &lt;/div&gt;
    &lt;div id='impact-factor'&gt;
        &lt;spam class="label label-danger"&gt;Impact factor&lt;/spam&gt;
        &lt;strong id='impact-factor-number-ejor'&gt;1.249&lt;/strong&gt;
        (Journal Citation Reports) | 1st Quartile
    &lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;Science Mapping Analysis of the Literature on Software Product Lines.&lt;/h3&gt;
&lt;p&gt;Heradio, R.; &lt;strong&gt;Perez-Morago, H.&lt;/strong&gt;; Fernandez-Amoros, D.; Cabrerizo, Francisco Javier; 
Herrera-Viedma, Enrique Conference Paper The 14th International Conference on 
Intelligent Software Methodologies, Tools and Techniques Monumental Complex of 
St. Chiara, Naples, Italy September 15-17, 2015&lt;/p&gt;
&lt;h3&gt;Binary Decision Diagram Algorithms to Perform Hard Analysis Operations on Variability Models.&lt;/h3&gt;
&lt;p&gt;Heradio, R.; &lt;strong&gt;Perez-Morago, H.&lt;/strong&gt;; Fernandez-Amoros, D.; 
Bean, Roberto; Cabrerizo, Francisco Javier; Cerrada, Carlos; Herrera-Viedma, Enrique
Conference Paper The 15th International Conference on Intelligent Software 
Methodologies, Tools and Techniques. Larnaca, Cyprus, 12-14, 2016&lt;/p&gt;
&lt;script type="text/javascript"&gt;
  var cors_api_url = 'https://cors-anywhere.herokuapp.com/';
  function doCORSRequest(options, printResult) {
    var x = new XMLHttpRequest();
    x.open(options.method, cors_api_url + options.url);
    x.onload = x.onerror = function() {
      var parser = new DOMParser();
      var doc = parser.parseFromString(x.responseText, "text/html");
      elem = doc.getElementsByClassName("header-impact-factor-sci")[0];
      elem = elem.getElementsByClassName("number")[0].innerHTML;
      printResult((elem || ''));
    };
    x.send();
  }

  // Bind event
  (function() {
    var urlField = document.getElementById('url');
    var outputField = document.getElementById('impact-factor-number-entropy');
    window.onload = function(e) {
      e.preventDefault();
      doCORSRequest({
        method: 'GET',
        url: 'https://mdpi.com/journal/entropy/stats#if',
      }, function printResult(result) {
        console.log(result);
        outputField.innerHTML += result;
      });
    };
  })();
&lt;/script&gt;</content><category term="About Me"></category><category term="research"></category><category term="publications"></category><category term="others"></category></entry><entry><title>Algoritmo de planificación First Come First Served</title><link href="/hectormorago/alg-fcfs.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/alg-fcfs.html</id><summary type="html">&lt;p&gt;Algoritmo de planificación First Come First Served.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;FCFS&lt;/h2&gt;
&lt;p&gt;Primero en llegar primero en ser servido, FCFS (First Come First Served). Es uno de los algoritmos de planificación 
más sencillos de implementar. El planificador maneja la cola de procesos como una cola FIFO. Entre sus &lt;strong&gt;ventajas&lt;/strong&gt; destacamos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Facilidad de implementación.&lt;/li&gt;
&lt;li&gt;Poca sobrecarga.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sus principales &lt;strong&gt;desventajas&lt;/strong&gt; son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Penaliza los procesos con tiempos de ráfaga más cortos con respecto a aquellos que tienen tiempo de ráfaga más largos.&lt;/li&gt;
&lt;li&gt;Puede aparecer lo que se denomina como efecto convoy.&lt;/li&gt;
&lt;li&gt;Sufre la anomalía de belady.&lt;/li&gt;
&lt;/ul&gt;</content><category term="blog"></category><category term="SSOO"></category><category term="algoritmos"></category><category term="otros"></category></entry><entry><title>Planificación de procesos</title><link href="/hectormorago/alg-planificacion.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/alg-planificacion.html</id><summary type="html">&lt;p&gt;Revisión de los principales algoritmos de planificación.&lt;/p&gt;</summary><content type="html">&lt;p&gt;En &lt;strong&gt;sistemas operativos multitarea&lt;/strong&gt;, donde podemos ejecutar cientos procesos al mismo tiempo,
necesitamos de herramientas que de algún modo &lt;strong&gt;multiplexen los recursos hardware&lt;/strong&gt; del sistema. Una de estas herramientas 
la proporciona el sistema operativo (SO), mediante el &lt;strong&gt;planificador&lt;/strong&gt; o scheduler. 
El planificador se encarga de repartir la CPU entre los procesos que se encuentran en el sistema listos para ejecutarse. 
Su funcionamiento básico se basa en la forma en la que los procesos se ejecutan, que consiste en realizar de forma alternativa 
ráfagas de CPU y de E/S (ver Figura 1). En función de la duración de dichas ráfagas podemos distinguir entre procesos que se 
encuentran limitados por la CPU (donde la duración de las ráfagas de CPU es mucho mayor que las de E/S) y procesos que se 
encuentran limitados por la E/S (donde la duración de las ráfagas de E/S es mucho mayor que las de E/S). El SO consciente de 
este funcionamiento aprovecha las ráfagas de E/S para ejecutar otro proceso, ya que en caso contrario la CPU se quedaría inactiva. &lt;/p&gt;
&lt;p&gt;En general podemos distinguir tres &lt;strong&gt;niveles de planificación&lt;/strong&gt;: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a corto plazo&lt;/strong&gt;, se encarga de decidir el siguiente proceso que pasará a ejecutarse de entre  aquellos que se encuentran 
preparados para su ejecución. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a medio plazo&lt;/strong&gt;, decide entre los procesos que están en memoria secundaria cual pasa a memoria principal, y viceversa. 
Es decir, regula el grado de multiprogramación. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a largo plazo&lt;/strong&gt;, decide qué trabajo de la cola de trabajo por lotes pasa a ser ejecutado en el sistema mediante la creación 
de un proceso.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Aparte de estos tres niveles de planificación se puede distinguir un cuarto nivel, la &lt;strong&gt;planificación de E/S&lt;/strong&gt; que
decide qué proceso en una cola de un dispositivo de E/S pasa a utilizar dicho dispositivo.&lt;/p&gt;
&lt;p&gt;La parte del SO que se encarga de realizar las tareas de planificación puede dividirse en los siguientes componentes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Encolador&lt;/strong&gt;  o enqueuer.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conmutador de contexto&lt;/strong&gt; o context switcher.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distribuidor&lt;/strong&gt;,  despachador o dispatcher. Se encarga de seleccionar un proceso de la cola de procesos preparados de 
acuerdo con un determinado algoritmo de planificación.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Es importante destacar que la tarea de planificación introduce &lt;strong&gt;sobrecarga&lt;/strong&gt;, es decir, tiempo que el SO está dedicado a tareas que no repercute en los procesos de los usuarios y que, por tanto, hay que minimizar. A la hora de seleccionar un algortimo de planificación podemos utilizar determinadas métricas como: &lt;strong&gt;Latencia de despacho&lt;/strong&gt;, es el tiempo promedio que tarda el distribuidor en detener un proceso y comenzar la ejecución de otro. Lo deseable que la latencia de despacho sea lo más pequeña posible. Sin embargo, muchos
SOs con objeto de asegurar la integridad de sus estructuras de datos no permiten que se pueda expropiar un proceso en modo núcleo que esté realizando una llamada al sistema, hasta que ésta no se complete o el proceso entre en el estado bloqueado. Tales SOs se dicen que son de núcleo no expropiable. En dicho caso la latencia de despacho puede ser larga ya que algunas llamadas al sistema son complejas.&lt;/p&gt;
&lt;p&gt;En general a la hora de planificar procesos vamos a tener en cuenta una serie de criterios generales:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Previsibilidad. Tareas similares igual tiempo.&lt;/li&gt;
&lt;li&gt;Uso equilibrado de recursos.&lt;/li&gt;
&lt;li&gt;Proporcionalidad. Tareas que parecen sencillas deben ejecutarse en plazos relativamente cortos.&lt;/li&gt;
&lt;li&gt;Equidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Entre los &lt;strong&gt;principales algoritmos de planificación&lt;/strong&gt; podemos citar los siguientes: 
&lt;a href="https://hperez30.github.io/alg-fcfs/"&gt;FCFS&lt;/a&gt;, &lt;a href="https://hperez30.github.io/alg-sjf/"&gt;SJF&lt;/a&gt;, 
&lt;a href="https://hperez30.github.io/alg-srt/"&gt;SRT&lt;/a&gt;, &lt;a href="https://hperez30.github.io/alg-round-robin/"&gt;Round Robin&lt;/a&gt;, etc.&lt;/p&gt;</content><category term="blog"></category><category term="SSOO"></category><category term="algoritmos"></category><category term="otros"></category></entry><entry><title>Algoritmo de planificación Round Robin</title><link href="/hectormorago/alg-round-robin.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/alg-round-robin.html</id><summary type="html">&lt;p&gt;Algoritmo de planificación Round Robin.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Round Robin&lt;/h2&gt;</content><category term="blog"></category><category term="SSOO"></category><category term="algoritmos"></category><category term="otros"></category></entry><entry><title>Algoritmo de planificación Shortest Job First</title><link href="/hectormorago/alg-sjf.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/alg-sjf.html</id><summary type="html">&lt;p&gt;Algoritmo de planificación Shortest Job First.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;SJF&lt;/h2&gt;
&lt;p&gt;Primero el que tiene un tiempo de ráfaga más corto, SJF (Shortest Job First). Este algoritmo de planificación selecciona 
como proceso para ser ejecutado a aquel que tiene un &lt;strong&gt;tiempo de ráfaga de CPU más corto&lt;/strong&gt;. Es un algoritmo difícil de 
implementar en la práctica ya que requiere conocer por adelantado los tiempos de ráfaga de CPU de todos los procesos, lo cual
no es posible. En vez de utilizar el tiempo real de ráfaga de CPU de los distintos procesos, lo que se suele utilizar es una 
estimación del tiempo de ráfaga de CPU basado en los tiempos de ráfaga pasados. 
Existen dos implementaciones de este algoritmo en función de si se sigue una planificación de tipo cooperativa o expropiativa. 
Entre sus &lt;strong&gt;principales ventajas&lt;/strong&gt; se encuentran las siguientes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Elimina algunos de los problemas del algoritmo FCFS.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sus principales desventajas son::&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Difícil de implementar.&lt;/li&gt;
&lt;li&gt;Sobrecarga introducidad en el sistema debido al cálculo de las estimaciones del tiempo de ráfaga de los procesos.&lt;/li&gt;
&lt;/ul&gt;</content><category term="blog"></category><category term="SSOO"></category><category term="algoritmos"></category><category term="otros"></category></entry><entry><title>Algoritmo de planificación Shortest Remaining Time</title><link href="/hectormorago/alg-srt.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/alg-srt.html</id><summary type="html">&lt;p&gt;Algoritmo de planificación Shortest Remaining Time.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;FCFS&lt;/h2&gt;
&lt;p&gt;Primero en llegar primero en ser servido, FCFS (First Come First Served). Es uno de los algoritmos de planificación 
más sencillos de implementar. El planificador maneja la cola de procesos como una cola FIFO. Entre sus ventajas destacamos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Facilidad de implementación.&lt;/li&gt;
&lt;li&gt;Poca sobrecarga.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sus principales desventajas son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Penaliza los procesos con tiempos de ráfaga más cortos con respecto a aquellos que tienen tiempo de ráfaga más largos.&lt;/li&gt;
&lt;li&gt;Puede aparecer lo que se denomina como efecto convoy.&lt;/li&gt;
&lt;li&gt;Sufre la anomalía de belady.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SJF&lt;/h2&gt;
&lt;p&gt;Primero el que tiene un tiempo de ráfaga más corto, SJF (Shortest Job First). Este algoritmo de planificación selecciona 
como proceso para ser ejecutado a aquel que tiene un tiempo de ráfaga de CPU más pequeño. Este algoritmo es difícil de 
implementar en la práctica ya que requiere conocer por adelantado los tiempos de ráfaga de CPU de todos los procesos, lo cual
no es posible. Para su implementación lo que se suele utilizar es un estimación del tiempo de ráfaga de CPU basado en los 
tiempos de ráfaga pasados. Existen dos implementaciones de este algoritmo en función de si se sigue una planificación de tipo
cooperativa o expropiativa. Entre sus principales ventajas se encuentran las siguientes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Elimina algunos de los problemas del algoritmo FCFS.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sus principales desventajas son::&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Difícil de implementar.&lt;/li&gt;
&lt;li&gt;Sobrecarga introducidad en el sistema debido al calculo de las estimaciones del tiempo de ráfaga de los procesos.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SRT&lt;/h2&gt;
&lt;h2&gt;Round Robin&lt;/h2&gt;</content><category term="blog"></category><category term="SSOO"></category><category term="algoritmos"></category><category term="otros"></category></entry><entry><title>Projects</title><link href="/hectormorago/projects.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/projects.html</id><summary type="html">&lt;p&gt;This section provides a summarize of my main projects.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Efficient Identification of Core and Dead Features in Variability Models&lt;/h2&gt;
&lt;h3&gt;Context&lt;/h3&gt;
&lt;p&gt;Variability models play a key role in product line engineering as they 
are used to represent the common and variable features that products may 
include, and what constraints among the features must be satisfied to 
guarantee the validity of the products. Valuable analysis operations on 
variability models can be performed by black box reusing logic engines, 
such as SAT-solvers and binary decision diagram libraries. Unfortunately, 
such kind of reuse implies long computation times for operations that 
need calling the engines many times. To overcome this problem, we work 
on new algorithms that directly deal with the data structure of a binary 
decision diagram encoding a variability model. In particular, the 
algorithm published in this site is specifically designed to detect core 
and dead features&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;
&lt;p&gt;This repository provides an algorithm to identify core and dead features, 
which is written in the C++ programming language as an extension of the 
&lt;a href="http://buddy.sourceforge.net/manual/main.html"&gt;BuDDy BDD package&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;More information about this project could be found in its&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://hperez30.github.io/CoreAndDeadFeatures/"&gt;main project page&lt;/a&gt;.&lt;/p&gt;</content><category term="Projects"></category><category term="research"></category><category term="projects"></category><category term="others"></category></entry></feed>