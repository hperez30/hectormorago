<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Hector' log - blog</title><link href="/hectormorago/" rel="alternate"></link><link href="/hectormorago/feeds/blog.atom.xml" rel="self"></link><id>/hectormorago/</id><updated>2020-07-07T20:31:00+02:00</updated><subtitle>A personal blog.</subtitle><entry><title>Normalización</title><link href="/hectormorago/normalizacion.html" rel="alternate"></link><published>2020-07-07T20:31:00+02:00</published><updated>2020-07-07T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-07-07:/hectormorago/normalizacion.html</id><summary type="html">&lt;p&gt;Teoria de normalizacion de BBDD.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;link rel="stylesheet" href="https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css"&gt;
La &lt;strong&gt;normalización&lt;/strong&gt; trata de comprobar mediante un método sistematico si una determinada relación es correcta, en el sentido de que no presenta redundancias. En el caso de que una relación, R, presente redundancias, deberemos de proceder a su descomposición de modo que las relaciones resultantes {R1, R2, R3, ... Rn} sean &lt;strong&gt;correctas&lt;/strong&gt; y &lt;strong&gt;no&lt;/strong&gt; presenten &lt;strong&gt;inconsistencias&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Al realizar el diseño de una base de datos, ya sea obteniendo el diseño relacional directamente o mediante el proceso en dos pasos (diseño conceptual y transformación a relacional), pueden aparecer los siguientes problemas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redundancias.&lt;/li&gt;
&lt;li&gt;Ambigüedades.&lt;/li&gt;
&lt;li&gt;Pérdida de información.&lt;/li&gt;
&lt;li&gt;Existencia de valores no aplicacbles o desconocidos.&lt;/li&gt;
&lt;li&gt;Aparición de estados que no son válidos en el mundo real.&lt;/li&gt;
&lt;li&gt;Pérdidas de relaciones entre los datos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Con el fin de evitar estos problemas surge la teoría de la normalización. Vamos a ver una relación de ejemplo en el que se presentan algunos de los problemas anteriormente citados.&lt;/p&gt;
&lt;p&gt;Sea la relación Estudiante_solicita_beca&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;cod_est&lt;/th&gt;
&lt;th&gt;nombre_est&lt;/th&gt;
&lt;th&gt;cod_beca&lt;/th&gt;
&lt;th&gt;nombre_beca&lt;/th&gt;
&lt;th&gt;fecha&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;Roberto&lt;/td&gt;
&lt;td&gt;B1&lt;/td&gt;
&lt;td&gt;Erasmus&lt;/td&gt;
&lt;td&gt;2020-01-21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Gema&lt;/td&gt;
&lt;td&gt;B2&lt;/td&gt;
&lt;td&gt;Apoyo biblioteca&lt;/td&gt;
&lt;td&gt;2018-02-22&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Laura&lt;/td&gt;
&lt;td&gt;B2&lt;/td&gt;
&lt;td&gt;Apoyo biblioteca&lt;/td&gt;
&lt;td&gt;2018-02-22&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Miguel&lt;/td&gt;
&lt;td&gt;B3&lt;/td&gt;
&lt;td&gt;Investigación&lt;/td&gt;
&lt;td&gt;2020-03-24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Pedro&lt;/td&gt;
&lt;td&gt;B1&lt;/td&gt;
&lt;td&gt;Erasmus&lt;/td&gt;
&lt;td&gt;2020-01-21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Miguel&lt;/td&gt;
&lt;td&gt;B1&lt;/td&gt;
&lt;td&gt;Erasmus&lt;/td&gt;
&lt;td&gt;2020-01-21&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;De un simple vistazo podemos ver algunos de los problemas mencionados. Por ejemplo, estamos almacenando de forma redundate los datos de un estudiante cada vez que realiza un solicitud, con los datos de las becas pasa los mismo. Otros problemas que nos podemos encontrar son inconsistencias debidas a la actualización de los datos de un estudiante o una beca en sólo algunas de las tuplas, problemas para almacenar los datos de estudiantes que no han solicitado becas o de becas que no han sido solicitadas, problemas en el borrado de solicitudes (perderíamos los datos del estudiante en el caso de sólo hubiese solicitado esa beca), etc.&lt;/p&gt;
&lt;p&gt;Con el fin de solventar todos estos problemas surge la teoría de la Normalización. Podemos afirmar que la teoría de la normalización permite afrontar el problema de diseño de bases de datos relacionales de una manera rigurosa y objetiva.
Una aspecto crucial en la normalización es el concepto de &lt;strong&gt;Dependencia Funcional&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Las dependencias nos permiten representar interdependencias entre los datos, son propiedades inherentes al contenido semántico de los datos y forman parte de las restricciones de usuario del Modelo Relacional.
Se han de cumplir en cualquier extensión de un esquema de relación (son invariantes en el tiempo).
No es posible deducir una dependencia a partir de la observación de una extensión del esquema de relación.
Existen diferentes tipos de dependencias: Funcionales, multivaluadas, jerárquicas y de combinación.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bibliografia&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tecnología y Diseño de Bases de Datos. M. Piattini, E. Marcos, C. Calero y B. Vela Ed.: RAMA. 2006&lt;/li&gt;
&lt;li&gt;Date, C. J. "An Introduction to Database Systems" (8ª edición), Addison-Wesley, 2004. (Versión en español: "Introducción a los Sistemas de Bases de Datos" (7ª edición), Pearson, 2001&lt;/li&gt;
&lt;li&gt;Batini, C., Ceri, S., Navathe, S. "Diseño Conceptual de Bases de Datos. Un enfoque de entidades-interrelaciones." Addison-Wesley Iberoamericana, 1994.&lt;/li&gt;
&lt;li&gt;Elsmari, R. y Navathe, S. B. "Sistemas de Bases de Datos. Conceptos Fundamentales." Addison-Wesley Iberoamericana, 1997. &lt;/li&gt;
&lt;/ul&gt;</content><category term="blog"></category><category term="BBDD"></category><category term="teoria"></category><category term="otros"></category></entry><entry><title>Algoritmo de planificación First Come First Served</title><link href="/hectormorago/alg-fcfs.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/alg-fcfs.html</id><summary type="html">&lt;p&gt;Algoritmo de planificación First Come First Served.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;FCFS&lt;/h2&gt;
&lt;p&gt;Primero en llegar primero en ser servido, FCFS (First Come First Served). Es uno de los algoritmos de planificación 
más sencillos de implementar. El planificador maneja la cola de procesos como una cola FIFO. Entre sus &lt;strong&gt;ventajas&lt;/strong&gt; destacamos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Facilidad de implementación.&lt;/li&gt;
&lt;li&gt;Poca sobrecarga.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sus principales &lt;strong&gt;desventajas&lt;/strong&gt; son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Penaliza los procesos con tiempos de ráfaga más cortos con respecto a aquellos que tienen tiempo de ráfaga más largos.&lt;/li&gt;
&lt;li&gt;Puede aparecer lo que se denomina como efecto convoy.&lt;/li&gt;
&lt;li&gt;Sufre la anomalía de belady.&lt;/li&gt;
&lt;/ul&gt;</content><category term="blog"></category><category term="SSOO"></category><category term="algoritmos"></category><category term="otros"></category></entry><entry><title>Planificación de procesos</title><link href="/hectormorago/alg-planificacion.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/alg-planificacion.html</id><summary type="html">&lt;p&gt;Revisión de los principales algoritmos de planificación.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;link rel="stylesheet" href="https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css"&gt;
En &lt;strong&gt;sistemas operativos multitarea&lt;/strong&gt;, donde podemos ejecutar cientos procesos al mismo tiempo,
necesitamos de herramientas que de algún modo &lt;strong&gt;multiplexen los recursos hardware&lt;/strong&gt; del sistema. Una de estas herramientas 
la proporciona el sistema operativo (SO), mediante el &lt;strong&gt;planificador&lt;/strong&gt; o scheduler. 
El planificador se encarga de repartir la CPU entre los procesos que se encuentran en el sistema listos para ejecutarse. 
Su funcionamiento básico se basa en la forma en la que los procesos se ejecutan, que consiste en realizar de forma alternativa 
ráfagas de CPU y de E/S (ver Figura 1). En función de la duración de dichas ráfagas podemos distinguir entre procesos que se 
encuentran limitados por la CPU (donde la duración de las ráfagas de CPU es mucho mayor que las de E/S) y procesos que se 
encuentran limitados por la E/S (donde la duración de las ráfagas de E/S es mucho mayor que las de E/S). El SO consciente de 
este funcionamiento aprovecha las ráfagas de E/S para ejecutar otro proceso, ya que en caso contrario la CPU se quedaría inactiva. &lt;/p&gt;
&lt;p&gt;En general podemos distinguir tres &lt;strong&gt;niveles de planificación&lt;/strong&gt;: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a corto plazo&lt;/strong&gt;, se encarga de decidir el siguiente proceso que pasará a ejecutarse de entre  aquellos que se encuentran 
preparados para su ejecución. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a medio plazo&lt;/strong&gt;, decide entre los procesos que están en memoria secundaria cual pasa a memoria principal, y viceversa. 
Es decir, regula el grado de multiprogramación. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a largo plazo&lt;/strong&gt;, decide qué trabajo de la cola de trabajo por lotes pasa a ser ejecutado en el sistema mediante la creación 
de un proceso.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Aparte de estos tres niveles de planificación se puede distinguir un cuarto nivel, la &lt;strong&gt;planificación de E/S&lt;/strong&gt; que
decide qué proceso en una cola de un dispositivo de E/S pasa a utilizar dicho dispositivo.&lt;/p&gt;
&lt;p&gt;La parte del SO que se encarga de realizar las tareas de planificación puede dividirse en los siguientes componentes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Encolador&lt;/strong&gt;  o enqueuer.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conmutador de contexto&lt;/strong&gt; o context switcher.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distribuidor&lt;/strong&gt;,  despachador o dispatcher. Se encarga de seleccionar un proceso de la cola de procesos preparados de 
acuerdo con un determinado algoritmo de planificación.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Es importante destacar que la tarea de planificación introduce &lt;strong&gt;sobrecarga&lt;/strong&gt;, es decir, tiempo que el SO está dedicado a tareas que no repercute en los procesos de los usuarios y que, por tanto, hay que minimizar. A la hora de seleccionar un algortimo de planificación podemos utilizar determinadas métricas como: &lt;strong&gt;Latencia de despacho&lt;/strong&gt;, es el tiempo promedio que tarda el distribuidor en detener un proceso y comenzar la ejecución de otro. Lo deseable que la latencia de despacho sea lo más pequeña posible. Sin embargo, muchos
SOs con objeto de asegurar la integridad de sus estructuras de datos no permiten que se pueda expropiar un proceso en modo núcleo que esté realizando una llamada al sistema, hasta que ésta no se complete o el proceso entre en el estado bloqueado. Tales SOs se dicen que son de núcleo no expropiable. En dicho caso la latencia de despacho puede ser larga ya que algunas llamadas al sistema son complejas.&lt;/p&gt;
&lt;p&gt;En general a la hora de planificar procesos vamos a tener en cuenta una serie de criterios generales:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Previsibilidad. Tareas similares igual tiempo.&lt;/li&gt;
&lt;li&gt;Uso equilibrado de recursos.&lt;/li&gt;
&lt;li&gt;Proporcionalidad. Tareas que parecen sencillas deben ejecutarse en plazos relativamente cortos.&lt;/li&gt;
&lt;li&gt;Equidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Entre los &lt;strong&gt;principales algoritmos de planificación&lt;/strong&gt; podemos citar los siguientes: 
&lt;a href="https://hperez30.github.io/alg-fcfs/"&gt;FCFS&lt;/a&gt;, &lt;a href="https://hperez30.github.io/alg-sjf/"&gt;SJF&lt;/a&gt;, 
&lt;a href="https://hperez30.github.io/alg-srt/"&gt;SRT&lt;/a&gt;, &lt;a href="https://hperez30.github.io/alg-round-robin/"&gt;Round Robin&lt;/a&gt;, etc.&lt;/p&gt;</content><category term="blog"></category><category term="SSOO"></category><category term="algoritmos"></category><category term="otros"></category></entry><entry><title>Algoritmo de planificación Round Robin</title><link href="/hectormorago/alg-round-robin.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/alg-round-robin.html</id><summary type="html">&lt;p&gt;Algoritmo de planificación Round Robin.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Round Robin&lt;/h2&gt;</content><category term="blog"></category><category term="SSOO"></category><category term="algoritmos"></category><category term="otros"></category></entry><entry><title>Algoritmo de planificación Shortest Job First</title><link href="/hectormorago/alg-sjf.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/alg-sjf.html</id><summary type="html">&lt;p&gt;Algoritmo de planificación Shortest Job First.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;SJF&lt;/h2&gt;
&lt;p&gt;Primero el que tiene un tiempo de ráfaga más corto, SJF (Shortest Job First). Este algoritmo de planificación selecciona 
como proceso para ser ejecutado a aquel que tiene un &lt;strong&gt;tiempo de ráfaga de CPU más corto&lt;/strong&gt;. Es un algoritmo difícil de 
implementar en la práctica ya que requiere conocer por adelantado los tiempos de ráfaga de CPU de todos los procesos, lo cual
no es posible. En vez de utilizar el tiempo real de ráfaga de CPU de los distintos procesos, lo que se suele utilizar es una 
estimación del tiempo de ráfaga de CPU basado en los tiempos de ráfaga pasados. 
Existen dos implementaciones de este algoritmo en función de si se sigue una planificación de tipo cooperativa o expropiativa. 
Entre sus &lt;strong&gt;principales ventajas&lt;/strong&gt; se encuentran las siguientes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Elimina algunos de los problemas del algoritmo FCFS.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sus principales desventajas son::&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Difícil de implementar.&lt;/li&gt;
&lt;li&gt;Sobrecarga introducidad en el sistema debido al cálculo de las estimaciones del tiempo de ráfaga de los procesos.&lt;/li&gt;
&lt;/ul&gt;</content><category term="blog"></category><category term="SSOO"></category><category term="algoritmos"></category><category term="otros"></category></entry><entry><title>Algoritmo de planificación Shortest Remaining Time</title><link href="/hectormorago/alg-srt.html" rel="alternate"></link><published>2020-04-06T20:31:00+02:00</published><updated>2020-04-06T20:31:00+02:00</updated><author><name>Hector Perez-Morago</name></author><id>tag:None,2020-04-06:/hectormorago/alg-srt.html</id><summary type="html">&lt;p&gt;Algoritmo de planificación Shortest Remaining Time.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;FCFS&lt;/h2&gt;
&lt;p&gt;Primero en llegar primero en ser servido, FCFS (First Come First Served). Es uno de los algoritmos de planificación 
más sencillos de implementar. El planificador maneja la cola de procesos como una cola FIFO. Entre sus ventajas destacamos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Facilidad de implementación.&lt;/li&gt;
&lt;li&gt;Poca sobrecarga.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sus principales desventajas son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Penaliza los procesos con tiempos de ráfaga más cortos con respecto a aquellos que tienen tiempo de ráfaga más largos.&lt;/li&gt;
&lt;li&gt;Puede aparecer lo que se denomina como efecto convoy.&lt;/li&gt;
&lt;li&gt;Sufre la anomalía de belady.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SJF&lt;/h2&gt;
&lt;p&gt;Primero el que tiene un tiempo de ráfaga más corto, SJF (Shortest Job First). Este algoritmo de planificación selecciona 
como proceso para ser ejecutado a aquel que tiene un tiempo de ráfaga de CPU más pequeño. Este algoritmo es difícil de 
implementar en la práctica ya que requiere conocer por adelantado los tiempos de ráfaga de CPU de todos los procesos, lo cual
no es posible. Para su implementación lo que se suele utilizar es un estimación del tiempo de ráfaga de CPU basado en los 
tiempos de ráfaga pasados. Existen dos implementaciones de este algoritmo en función de si se sigue una planificación de tipo
cooperativa o expropiativa. Entre sus principales ventajas se encuentran las siguientes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Elimina algunos de los problemas del algoritmo FCFS.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sus principales desventajas son::&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Difícil de implementar.&lt;/li&gt;
&lt;li&gt;Sobrecarga introducidad en el sistema debido al calculo de las estimaciones del tiempo de ráfaga de los procesos.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SRT&lt;/h2&gt;
&lt;h2&gt;Round Robin&lt;/h2&gt;</content><category term="blog"></category><category term="SSOO"></category><category term="algoritmos"></category><category term="otros"></category></entry></feed>